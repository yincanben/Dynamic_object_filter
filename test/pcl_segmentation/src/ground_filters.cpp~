/*************************************************************************
	> File Name: ground_filters.cpp
	> Author: yincanben
	> Mail: yincanben@163.com
	> Created Time: Fri 02 Jan 2015 09:37:38 AM CST
 ************************************************************************/

#include <iostream>
#include <boost/foreach.hpp>

//#include "ros/ros.h"
//#include <pcl_ros/point_cloud.h>

#include <pcl/point_types.h>

//#include <pcl/ros/subscriber.h>
//#include <pcl/ros/publisher.h>

#include <pcl/io/pcd_io.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/kdtree/kdtree.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/visualization/cloud_viewer.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/filters/passthrough.h>

using namespace std ;

typedef pcl::PointCloud<pcl::PointXYZRGB> PointCloud ;

//point_cloud::Publisher<pcl::PointXYZRGB> pub;
//point_cloud::Publisher<pcl::PointXYZRGB> pub2;

void segment(pcl::PointCloud<pcl::PointXYZRGB> cloud)
{
    pcl::PointCloud<pcl::PointXYZRGB> ground_points;
    pcl::PointCloud<pcl::PointXYZRGB> object_points;
    pcl::PointCloud<pcl::PointXYZRGB> cloud_filtered;

    std::cout << "Total points: " << cloud.points.size() << std::endl;
    // Step 0 : Filter out NaNs from data (this is necessary now) ...
    pcl::PassThrough<pcl::PointXYZRGB> nan_remover;
    nan_remover.setInputCloud(boost::make_shared<pcl::PointCloud<pcl::PointXYZRGB> >(cloud));
    nan_remover.setFilterFieldName("z");
    nan_remover.setFilterLimits(0.0, 10.0);
    nan_remover.filter(cloud);
    
    // Step 1: Filter out statistical outliers
    pcl::StatisticalOutlierRemoval<pcl::PointXYZRGB> sor ;
    sor.setInputCloud(boost::make_shared<pcl::PointCloud<pcl::PointXYZRGB> >(cloud)) ;
    sor.setMeanK(50) ;
    sor.setStddevMulThresh(1.0) ;
    sor.filter(cloud_filtered) ;

    // Step 2: Downsample the point cloud (to save time in the next step)
    pcl::VoxelGrid<pcl::PointXYZRGB> downsampler ;
    downsampler.setInputCloud(boost::make_shared<pcl::PointCloud<pcl::PointXYZRGB> >(cloud_filtered)) ;
    downsampler.setLeafSize(0.01, 0.01, 0.01) ; // leaf size of 1cm
    downsampler.filter(cloud_filtered) ;

    //ROS_INFO("After filtering: %d", cloud_filtered.width * cloud_filtered.height);
    cout << "After filtering: " << cloud_filtered.width * cloud_filtered.height << endl;
    

    // Step 3: Find the ground plane using RANSAC
    pcl::ModelCoefficients coefficients ;
    pcl::PointIndices inliers ;
    pcl::SACSegmentation<pcl::PointXYZRGB> seg ;
    seg.setOptimizeCoefficients(true) ; // Optional
    // seg.setMaxIterations(500); // Optional, maybe can be lower
    seg.setModelType(pcl::SACMODEL_PLANE) ;
    seg.setMethodType(pcl::SAC_RANSAC) ;
    seg.setDistanceThreshold(0.02) ;
    seg.setInputCloud(boost::make_shared<pcl::PointCloud<pcl::PointXYZRGB> >(cloud_filtered)) ;
    seg.segment(inliers, coefficients) ;

    if (inliers.indices.size() == 0)
    {
        //ROS_ERROR ("Could not estimate a planar model for the given dataset.");
        cout << "No planr model" << endl ;
    }

    std::cout << "Model inliers: " << inliers.indices.size() << std::endl ;

    // Step 3.1 : Extract the points that lie in the ground plane
    pcl::ExtractIndices<pcl::PointXYZRGB> extract ;
    extract.setInputCloud(boost::make_shared<pcl::PointCloud<pcl::PointXYZRGB> >(cloud_filtered));
    extract.setIndices(boost::make_shared<pcl::PointIndices>(inliers));
    extract.filter(ground_points);

    // Step 3.2 : Extract the points that are objects (i.e., are not in the ground plane)
    extract.setNegative(true) ;
    extract.filter(object_points) ;

    //Step 4 : EuclideanClusters Extract moving objects
    pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZRGB>);
    tree->setInputCloud ( boost::make_shared<pcl::PointCloud<pcl::PointXYZRGB> >(object_points ));
    pcl::PCDWriter writer ;

    std::vector<pcl::PointIndices> cluster_indices ;
    pcl::EuclideanClusterExtraction<pcl::PointXYZRGB> ec ;
    ec.setClusterTolerance (0.02) ; // 2cm
    ec.setMinClusterSize (1000) ;
    ec.setMaxClusterSize (25000) ;
    ec.setSearchMethod (tree) ;
    ec.setInputCloud ( boost::make_shared<pcl::PointCloud<pcl::PointXYZRGB> >(object_points )) ;
    ec.extract (cluster_indices) ;

    int j = 0 ;
    for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it){
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_cluster (new pcl::PointCloud<pcl::PointXYZRGB>);
        for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); pit++)
            cloud_cluster->points.push_back (object_points.points[*pit]); 
        cloud_cluster->width = cloud_cluster->points.size ();
        cloud_cluster->height = 1;
        cloud_cluster->is_dense = true;

        std::cout << "PointCloud representing the Cluster: " << cloud_cluster->points.size () << " data points." << std::endl;
        std::stringstream ss;
        ss << "cloud_cluster_" << j << ".pcd";
        writer.write<pcl::PointXYZRGB> (ss.str (), *cloud_cluster, false); 
        j++;
    }

    //pub.publish(ground_points) ;
    //pub2.publish(object_points) ;
}

void callback(const pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr& msg)
{
    printf("Cloud: width = %u, height = %u\n", msg->width, msg->height );
    BOOST_FOREACH (const pcl::PointXYZRGB pt, msg->points){
        printf("\t(%f, %f, %f)\n", pt.x, pt.y, pt.z) ;
    }
    //ROS_INFO("callback");

    //Save the point cloud to file
    //pcl::io::savePCDFile("test.pcd", *msg, false) ;
    //ros::shutdown() ;

    //segment(*msg);
}

int main(int argc, char** argv)
{
    /*
    // Standard node stuff
    ros::init(argc, argv, "point_cloud_listener") ;
    ros::NodeHandle nh ;

    // Subscriber the PointCloud
    ros::Subscriber point_cloud_sub_ = nh.subscribe<PointCloud>("depth/points", 1, callback) ;
    ros::spin();
    //pub.advertise(nh, "floor_points", 1);
    //pub2.advertise(nh, "object_points", 1);

    //point_cloud::Subscriber<pcl::PointXYZRGB> sub;
    //sub.subscribe(nh, "/stereo/points2", 1, callback);
    */

    // PROCESS
    //  sensor_msgs::PointCloud2 cloud_blob;
    pcl::PointCloud<pcl::PointXYZRGB> cloud;
    
    if (pcl::io::loadPCDFile("../images/test.pcd", cloud) == -1){
        //ROS_ERROR ("Couldn't read file test_pcd.pcd");
        cout << "cann't read test.pcd" << endl ;
        return (-1);
    }
    //  ROS_INFO ("Loaded %d data points from test_pcd.pcd with the following fields: %s", (int)(cloud_blob.width * cloud_blob.height), pcl::getFieldsList (cloud_blob).c_str ());
    //
    // Convert to the templated message type
    //point_cloud::fromMsg(cloud_blob, cloud);
    
    segment(cloud);

    return 0;

}
