/*************************************************************************
	> File Name: wapImage.cpp
	> Author: yincanben
	> Mail: yincanben@163.com
	> Created Time: Tue 24 Mar 2015 08:34:01 AM CST
 ************************************************************************/

#include<iostream>

#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <opencv2/calib3d/calib3d.hpp>
#include <opencv2/nonfree/nonfree.hpp>
#include <opencv2/nonfree/features2d.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

using namespace std;
int main(int argc, char**argv){
	 cv::Mat lastImage = cv::imread( argv[1], CV_LOAD_IMAGE_COLOR );
	 cv::Mat grayImage = cv::imread( argv[2], CV_LOAD_IMAGE_COLOR );
	 if(!lastImage.data){
		cout << "Cloud not read the image!" << endl ;
	 	return -1 ;
	 }
	 cv::ORB orb ;
     std::vector<cv::KeyPoint> lastKeypoints ;
     std::vector<cv::KeyPoint> keypoints ;
     
     //featureDetector_ ->detect( grayImage, keypoints ) ;
     //ROS_INFO( "The size of keypoints: %d", keypoints.size() ) ;
     //if( keypoints.size() == 0 )
     //    return ;
     //Step 2: Calculate descriptors (features vectors)
     cv::Mat lastDescriptors ;
     cv::Mat descriptors ;

     
     orb( lastImage, cv::Mat(), lastKeypoints, lastDescriptors) ;
     orb( grayImage, cv::Mat(), keypoints, descriptors );
    

     cv::BFMatcher matcher(cv::NORM_L2) ;
     //cv::BruteForceMatcher<cv::HammingLUT> matcher ;
     std::vector<cv::DMatch> matches ;
     //matcher.match( lastDescriptors, descriptors, matches );
     std::vector<cv::DMatch> goodMatches ;
     double minDist = 1000.0 , maxDist = 0.0 ;
     cv::Mat img_matches ;
     std::vector<cv::Point2f> lastPoint ;
     std::vector<cv::Point2f> currentPoint ;


     if(!lastDescriptors.empty()){
         //cout << "************" << endl ;
         matcher.match( lastDescriptors, descriptors, matches );
         for(int i=0; i<lastDescriptors.rows; i++){
             double dist = matches[i].distance ;
             if(dist < minDist)
                 minDist = dist ;
             if(dist > maxDist)
                 maxDist = dist ;    
         }

         for(int i=0; i<lastDescriptors.rows; i++){
             if( matches[i].distance < 0.6*maxDist ){
                 goodMatches.push_back(matches[i]);
             }
         }

         //draw matches
         
         cv::namedWindow("matches") ;
         cv::drawMatches( lastImage, lastKeypoints, grayImage, keypoints, goodMatches,img_matches, cv::Scalar::all(-1), cv::Scalar::all(-1),std::vector<char>(), cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);
         imshow("matches", img_matches) ;
         cv::imwrite( "matches.jpg", img_matches ) ;
         if(cv::waitKey(1) > 0){
             exit(0);
         }

         if(goodMatches.size() > 4){
             for( int i=0; i<goodMatches.size();i++ ){
                 lastPoint.push_back( lastKeypoints[goodMatches[i].queryIdx].pt );
                 currentPoint.push_back( keypoints[goodMatches[i].trainIdx].pt );
             }
             Homography = cv::findHomography( lastPoint, currentPoint, CV_RANSAC ) ;
         }
         cv::Mat dst ;
         cv::warpPerspective( grayImage, dst, Homography, cv::Size(grayImage.rows, grayImage.cols));
     }
}

